<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Serveur RPiMaster</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <script type="text/javascript" src="/d3.v7.min.js"></script>
    <link rel="stylesheet" href="/normalize.css">
    <link rel="stylesheet" href="/skeleton.css">
    <style>
        .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 1.5px;
        }
        .zoom {
            cursor: move;
            fill: none;
            pointer-events: all;
        }

        .shadow{
            box-shadow: 10px -10px 5px #00f;
            text-shadow: -2px 0 2px #fff, 0 2px 2px #fff, 2px 0 2px #fff, 0 -2px 2px #fff,
                         -2px 2px 2px #fff, 2px 2px 2px #fff, 2px -2px 2px #fff, -2px -2px 2px #fff;
        }
        
        </style>
</head>
<body>
    <svg id="SvgChart" width="960" height="500"></svg>
    <pre>
        <code id="status"></code>
    </pre>
</body>
<script>
    var areaWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
        areaHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    var margin = {top: 20, right: 70, bottom: 50, left: 70},
        width = areaWidth - margin.left - margin.right, // zone de tracage
        height = areaHeight - margin.top - margin.bottom; // zone de tracage

    var url = window.location.pathname.split('/');
    // var serie =  [{name:'CO2', Unit:'xx', precision:1, NbPoints:width, type:'type'}]
</script>

<script>
    const NbPts = Math.round(width/2);
    var serie = (url[url.length-1].split(',')).map(
        item => {
            [name,type] = item.split('.')
            // console.log('[name,type]', [name,type])
            if (type) {
                return {name:name, Unit:'V', precision:0.001, NbPoints:NbPts, tags:[type]};
            }
            return {name:name, Unit:'$', precision:0.001, NbPoints:NbPts};
        }
    )
    // console.log('serie', serie)
    

    // var serie =  [{name:'CO2', Unit:'xx', precision:1, NbPoints:width, type:'type'}]
    var serie = [
            {name:'voltage', Unit:'V', precision:0.001, NbPoints:NbPts, tags:['PowerSupply']},
            {name:'CO2', Unit:'ppm', precision:10, NbPoints:NbPts},
            {name:'pressure', Unit:'Pa', precision:1, NbPoints:NbPts},
            {name:'voltage', Unit:'V', precision:0.001, NbPoints:NbPts, tags:['Battery']},
            {name:'temperature', Unit:'Â°C', precision:0.01, NbPoints:NbPts},
            {name:'humidity', Unit:'%', precision:0.1, NbPoints:NbPts},
        ]
    // console.log('serie', serie)
    
    var Request = {
            serie:serie,
            DateStart: d3.isoParse("2022-06-07T11:00:00.000Z"),
            DateEnd: new Date(), // (new Date(Date.now() + 2 * (60 * 60 * 1000))) // (new date()).toISOString()
            yScales:{},
        }
</script>



<script>

    // var colorScale = d3.scaleOrdinal(d3.schemeCategory10);
    var colorScale = d3.scaleOrdinal(d3.schemePaired);
    
    var svg = d3.select('#SvgChart')
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
    // definition de l'echelle horizontale commune
    Request.xScale = d3.scaleUtc()
                .domain([d3.isoParse(Request.DateStart), d3.isoParse(Request.DateEnd)])
                .range([0, width]);
    
        // Add the x Axis
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(Request.xScale))
            .transition().duration(1000).call(d3.axisBottom(Request.xScale));

    var formatDate = d3.timeFormat("%Y-%m-%d %H:%M:%S"),
        bisectDate = d3.bisector(function(d) {return d.date; }).left;

    function axisBuild(yAxe){
        // console.log('yAxe['+yAxe.count+']',yAxe.Unit)
        switch (yAxe.count) {
            case 0:
                // Add the y Axis Left oriented Left
                svg.append("g")
                    .call(d3.axisLeft(yAxe))
                    .call(g => g.selectAll(".tick text").append("tspan").text(yAxe.Unit));
                xAxis = 0;
                break;
            case 1:
                // Add the y Axis Right oriented Right
                svg.append("g")
                    .call(d3.axisRight(yAxe))
                    .call(g => g.selectAll(".tick text").append("tspan").text(yAxe.Unit))
                    .attr("transform", "translate(" + width + ",0)");
                xAxis = width;
                break;
            case 2:
                // Add the y Axis Left oriented Right
                svg.append("g")
                    .call(d3.axisRight(yAxe))
                    .call(g => g.selectAll(".tick text").append("tspan").text(yAxe.Unit));            
                xAxis = 0;
                break;
            case 3:
                // Add the y Axis Right oriented Left
                svg.append("g")
                    .call(d3.axisLeft(yAxe))
                    .call(g => g.selectAll(".tick text").append("tspan").text(yAxe.Unit))
                    .attr("transform", "translate(" + width + ",0)");
                xAxis = width;
                break;
            default: // on ne peu afficher que 4 Axes, les suivant sont cache
                xAxis = null;
                break;
        }
        return xAxis;
    }

    function mousemove() {
        var x0 = Request.xScale.invert(d3.pointer(event,this)[0]);
        Request.serie.forEach( Curve => {
            var i = bisectDate(Curve.data, x0, 1);
            var d0 = Curve.data[i - 1],
                d1 = Curve.data[i],
                d = x0 - d0.date > d1.date - x0 ? d1 : d0;
            // console.log('Request', Request);
            // console.log('Curve', Curve);
            Curve.focus.selectAll("circle.y-"+Curve.Count) // Cercle
                .attr("transform","translate(" + Request.xScale(d.date) + "," +Request.yScales[Curve.Unit](d.value) + ")");
            Curve.focus.select("text.y1") // Valeur et Unite
                .attr("transform","translate(" + Request.xScale(d.date) + "," + Request.yScales[Curve.Unit](d.value) + ")")
                .text(d.value+Curve.Unit);
            if(Curve.Count == 0){
                Curve.focus.select(".x") // repere vertical commun
                    .attr("transform","translate(" + Request.xScale(d.date) + ",0)")
                    // .attr("y1", height)
                    .attr("y2", height);
                Curve.focus.select("text.y3") // date
                    .attr("transform","translate(" + (Request.xScale(d.date)-87) + ","+(height-18)+")")
                    .text(formatDate(d.date));
            }
            if (null != Curve.xAxis){
                Curve.focus.select(".y-"+Curve.Count) // repere Y horizontal
                    .attr("transform","translate(0," +Request.yScales[Curve.Unit](d.value) + ")")
                    .attr("x1",Curve.xAxis)
                    .attr("x2", Request.xScale(d.date));
            }
        })


    }

    const GetData = function(serie) {
        serie.Color = {
            low:colorScale(2*serieCounter),
            high:colorScale(2*serieCounter+1)
        }
        serie.Count = serieCounter++;
        Request.yScales.count = 0
        // console.log('Serie['+serieCounter+']',serie.name, serie);
        // console.log('DateRange=', Request.DateStart, Request.DateEnd);
        // console.log('DateRange=', Request.DateStart.toISOString(), Request.DateEnd.toISOString());
        var Tags = serie.tags ? serie.tags.map(tags => {
            // console.log('tags', tags);
            return {
                operator:"and",
                name: "type",
                value: tags
            };
        }) : [];

        return d3.json('/API/db/read', { // collecte des data Raw aupres du server
            method:"POST",
            body: JSON.stringify({
                serie: serie.name,
                tags: Tags,
                    // [{
                    //     operator:"and",
                    //     name: "type",
                    //     value: serie.type
                    // }]
                times: {
                    start: Request.DateStart,
                    end: Request.DateEnd
                },
                precision: serie.precision,
                NbPoints: serie.NbPoints
            }),
            headers: {
                "Content-type": "application/json; charset=UTF-8"
            }
        })
        .then(json => { // Mise en forme des data au format pour D3.js
            // console.log('json=',json)
            serie.data = json.filter( function(d) { return d.mean !== null}).map(data => {
                const date = d3.isoParse(data.time);
                const value = data.mean;
                    return {date, value};
            });
            // console.log('serie=',serie)
            return serie;
        })
        .then( // Construction des Axes X et raprochement en cas d'unite similaire
            Serie => {
                if (!Request.yScales[Serie.Unit]){ // si l'axe Y de cette unite n'existe pas
                    Request.yScales[Serie.Unit] = d3.scaleLinear()
                        .domain(d3.extent(Serie.data, d => d.value)) // [d3.min(Serie.data, d => d.value), d3.max(Serie.data, d => d.value)]
                        .range([height, 0]);
                    Request.yScales[Serie.Unit].count = (Request.yScales.count)
                    Request.yScales.count++
                } else{
                    var dataDomain = Request.yScales[Serie.Unit]
                                            .domain()
                                            .concat(d3.extent(Serie.data, d => d.value))
                    // console.log('dataDomain',dataDomain);
                    Request.yScales[Serie.Unit]
                            .domain(d3.extent(dataDomain));
                    // console.log('d3.extent(dataDomain)',Request.yScales[Serie.Unit].domain());
                }
                // return Serie;
            }
        )
    }

    var serieCounter=0;
    const DataPromise = Request.serie.map(serie => GetData(serie))
    Promise
        .all(DataPromise)
        .then(
            () => {
                // console.log('Request.serie',Request.serie);
                return Request.serie.map(
                    Curve => {
                        // console.log('Curve=',Curve)
                        // console.log('Request.yScales',Request.yScales);
                        // console.log('Request.yScales['+Curve.Unit+']',Request.yScales[(Curve.Unit)]);
                        Curve.line = d3.line()
                            // .defined(function (d) { return d; })
                            // .defined(function (d) { return d[1] !== null; })
                            // .defined(function (d) { return d.y !== null; })
                            // .defined(function (d) { return d.y; })
                            .x(d => Request.xScale(d.date))
                            .y(d => Request.yScales[Curve.Unit](d.value))
                            .curve(d3.curveMonotoneX) // curveBundle, curveCatmullRom.alpha(1), curveCardinal, curveMonotoneX
                        Curve.xAxis = axisBuild(Request.yScales[(Curve.Unit)]);

                        // Set the gradient
                        svg.append("linearGradient")
                            .attr("id", "line-gradient-"+Curve.Count)
                            .attr("gradientUnits", "userSpaceOnUse")
                            .attr("x1", 0)
                            .attr("y1", Request.yScales[Curve.Unit](d3.min(Curve.data, d => d.value)))
                            .attr("x2", 0)
                            .attr("y2", Request.yScales[Curve.Unit](d3.max(Curve.data, d => d.value)))
                            .selectAll("stop")
                            .data([
                                {offset: "0%", color: Curve.Color.low},
                                {offset: "100%", color: Curve.Color.high}
                            ])
                            .enter().append("stop")
                            .attr("offset", function(d) { return d.offset; })
                            .attr("stop-color", function(d) { return d.color; });

                        var line = svg.append("path")
                            .datum(Curve.data)
                            .attr("z-index", -1)
                            .attr("fill", "none")
                            .attr("stroke", "url(#line-gradient-"+Curve.Count+")" )
                            .attr("stroke-width", 1)
                            .attr("d", Curve.line)
                            .transition()
                            .duration(1000)

                        // Construction du cursseur
                        Curve.focus = svg.append("g") 
                                    .style("display", "none");

                        if(Curve.Count == 0){
                            // append the X line Verticale
                            Curve.focus.append("line")
                                .attr("class", "x")
                                .style("stroke", 'gray')
                                .style("stroke-dasharray", "3,3") // pointillees
                                // .style("opacity", 0.5)
                                .attr("y1", 0)
                                .attr("y2", height);

                            // place the date at the intersection
                            Curve.focus.append("text")
                                .attr("class", "y3 shadow")
                                .attr("dx", 8)
                                .attr("dy", "1em");
                        }
                        if (null != Curve.xAxis){
                            // append the y line Horizontale
                            Curve.focus.append("line")
                                .attr("class", "y-"+Curve.Count)
                                .style("stroke", Curve.Color.high)
                                .style("stroke-dasharray", "3,3") // pointillees
                                .style("opacity", 0.5)
                                .attr("x1", width)
                                .attr("x2", width);
                        }

                        // append the circle at the intersection 
                        Curve.focus.append("circle")
                            .attr("class", "y-"+Curve.Count)
                            .style("fill", "none")
                            .style("stroke-width", "5px")
                            .style("stroke", "white")
                            .attr("r", 6);

                        Curve.focus.append("circle")
                            .attr("class", "y-"+Curve.Count)
                            .style("fill", "none")
                            .style("stroke", Curve.Color.high)
                            .attr("r", 6);

                        // place the value at the intersection
                        Curve.focus.append("text")
                            .attr("class", "y1 shadow")
                            .attr("dx", 8)
                            .attr("dy", "-.3em");

                        return Curve
                    }
                )
            }
        )
    // Request.yScales.forEach(yAxes => ConstructYAxes(yAxes))
    // Request.serie.forEach(serie => DrawCurve(serie))

    // append the rectangle to capture mouse
    var Sensitive = svg.append("rect")
        .attr("width", width)
        .attr("height", height)
        .style("fill", "none")
        .style("pointer-events", "all")
        .on("mouseover", function() { Request.serie.forEach(Curve => Curve.focus.style("display", null)); })
        .on("mouseout", function() { Request.serie.forEach(Curve => Curve.focus.style("display", "none")); })
        .on("mousemove", mousemove);
    

</script>
</html>