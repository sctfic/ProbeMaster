<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Serveur RPiMaster</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <script type="text/javascript" src="/d3.v7.min.js"></script>
    <link rel="stylesheet" href="/normalize.css">
    <link rel="stylesheet" href="/skeleton.css">
    <style>
        .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 1.5px;
        }
        .zoom {
            cursor: move;
            fill: none;
            pointer-events: all;
        }

        .shadow{
            box-shadow: 10px -10px 5px #00f;
            text-shadow: -2px 0 2px #fff, 0 2px 2px #fff, 2px 0 2px #fff, 0 -2px 2px #fff,
                         -2px 2px 2px #fff, 2px 2px 2px #fff, 2px -2px 2px #fff, -2px -2px 2px #fff;
        }
        
        </style>
</head>
<body>
    <svg id="SvgChart" width="960" height="500"></svg>
    <pre>
        <code id="status"></code>
    </pre>
</body>
<script>
    var areaWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
        areaHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    var margin = {top: 20, right: 70, bottom: 50, left: 70},
        width = areaWidth - margin.left - margin.right, // zone de tracage
        height = areaHeight - margin.top - margin.bottom; // zone de tracage

        
    var url = window.location.pathname.split('/');
    // var serie =  [{name:'CO2', Unit:'xx', precision:1, NbPoints:width, type:'type'}]
    []
    var serie = (url[url.length-1].split(',')).map(
        item => {
            [name,type] = item.split('.')
            // console.log('[name,type]', [name,type])
            if (type) {
                return {name:name, Unit:'V', precision:0.01, NbPoints:Math.round(width/2), tags:[type]};
            }
            return {name:name, Unit:'$', precision:1, NbPoints:Math.round(width/2)};
        }
    )
    // console.log('serie', serie)

    var Request = {
            serie:serie,
            DateStart: d3.isoParse("2022-05-16T00:00:00.000Z"),
            DateEnd: new Date() // (new Date(Date.now() + 2 * (60 * 60 * 1000))) // (new date()).toISOString()
        }

    // var colorScale = d3.scaleOrdinal(d3.schemeCategory10);
    var colorScale = d3.scaleOrdinal(d3.schemePaired);
    
    var svg = d3.select('#SvgChart')
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
    // definition de l'echelle horizontale commune
    Request.xScale = d3.scaleUtc()
                .domain([d3.isoParse(Request.DateStart), d3.isoParse(Request.DateEnd)])
                .range([0, width]);
    
        // Add the x Axis
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(Request.xScale))
            .transition().duration(1000).call(d3.axisBottom(Request.xScale));

    var formatDate = d3.timeFormat("%Y-%m-%d %H:%M:%S"),
        bisectDate = d3.bisector(function(d) {return d.date; }).left;

    function axisBuild(Curve){
        switch (Curve.Count) {
            case 0:
                // Add the y Axis Left oriented Left
                svg.append("g")
                    .call(d3.axisLeft(Curve.yScale))
                    .call(g => g.selectAll(".tick text").append("tspan").text(Curve.Unit));
                break;
            case 1:
                // Add the y Axis Right oriented Right
                svg.append("g")
                    .call(d3.axisRight(Curve.yScale))
                    .call(g => g.selectAll(".tick text").append("tspan").text(Curve.Unit))
                    .attr("transform", "translate(" + width + ",0)");
                break;
            case 2:
                // Add the y Axis Left oriented Right
                svg.append("g")
                    .call(d3.axisRight(Curve.yScale))
                    .call(g => g.selectAll(".tick text").append("tspan").text(Curve.Unit));            
                break;
            case 3:
                // Add the y Axis Right oriented Left
                svg.append("g")
                    .call(d3.axisLeft(Curve.yScale))
                    .call(g => g.selectAll(".tick text").append("tspan").text(Curve.Unit))
                    .attr("transform", "translate(" + width + ",0)");
                break;
            default:
                break;
        }
    }

    function mousemove() {
        var x0 = Request.xScale.invert(d3.pointer(event,this)[0]);
        Request.serie.forEach( Curve => {
            var i = bisectDate(Curve.data, x0, 1);
            var d0 = Curve.data[i - 1],
                d1 = Curve.data[i],
                d = x0 - d0.date > d1.date - x0 ? d1 : d0;
            Curve.focus.selectAll("circle.y-"+Curve.Count)
                .attr("transform","translate(" + Request.xScale(d.date) + "," +Curve.yScale(d.value) + ")");
            Curve.focus.select("text.y1")
                .attr("transform","translate(" + Request.xScale(d.date) + "," + Curve.yScale(d.value) + ")")
                .text(d.value+Curve.Unit);
            Curve.focus.select("text.y3")
                .attr("transform","translate(" + Request.xScale(d.date) + "," +Curve.yScale(d.value) + ")")
                .text(formatDate(d.date));
            Curve.focus.select(".x")
                .attr("transform","translate(" + Request.xScale(d.date) + "," +Curve.yScale(d.value) + ")")
                .attr("y2", height - Curve.yScale(d.value)-3);
            Curve.focus.select(".y-"+Curve.Count)
                .attr("transform","translate(" + width * -1 + "," +Curve.yScale(d.value) + ")")
                .attr("x1", width)
                .attr("x2", width + Request.xScale(d.date)-3);
        })


    }

    const GetData = function(serie) {
        serie.Color = {
            low:colorScale(2*serieCounter),
            high:colorScale(2*serieCounter+1)
        }
        serie.Count = serieCounter++;
        // console.log('serie.Count',serie.Count);

        // console.log('Serie['+serieCounter+']',serie.name, serie);
        // console.log('DateRange=', Request.DateStart, Request.DateEnd);
        // console.log('DateRange=', Request.DateStart.toISOString(), Request.DateEnd.toISOString());
        var Tags = serie.tags ? serie.tags.map(tags => {
            console.log('tags', tags);
            return {
                operator:"and",
                name: "type",
                value: tags
            };
        }) : [];
        console.log('Tags', Tags);

        d3.json('/API/db/read', {
            method:"POST",
            body: JSON.stringify({
                serie: serie.name,
                tags: Tags,
                    // [{
                    //     operator:"and",
                    //     name: "type",
                    //     value: serie.type
                    // }]
                times: {
                    start: Request.DateStart,
                    end: Request.DateEnd
                },
                precision: serie.precision,
                NbPoints: serie.NbPoints
            }),
            headers: {
                "Content-type": "application/json; charset=UTF-8"
            }
        })
        .then(json => {
            // console.log('json=',json)

            serie.data = json.filter( function(d) { return d.mean !== null}).map(data => {
                const date = d3.isoParse(data.time);
                const value = data.mean;
                    return {date, value};
            });
            console.log('serie=',serie)
            return serie;
        })
        .then(
            Curve => {
                Curve.yScale = d3.scaleLinear()
                    .domain(d3.extent(Curve.data, d => d.value)) // [d3.min(Curve.data, d => d.value), d3.max(Curve.data, d => d.value)]
                    .range([height, 0]);
                // console.log('Curve.yScale=',Curve.yScale);

                Curve.line = d3.line()
                    // .defined(function (d) { return d; })
                    // .defined(function (d) { return d[1] !== null; })
                    // .defined(function (d) { return d.y !== null; })
                    // .defined(function (d) { return d.y; })
                    .x(d => Request.xScale(d.date))
                    .y(d => Curve.yScale(d.value))
                    .curve(d3.curveMonotoneX) // curveBundle, curveCatmullRom.alpha(1), curveCardinal, curveMonotoneX
                
                console.log('Curve=',Curve)

                axisBuild(Curve);

                // Set the gradient
                svg.append("linearGradient")
                    .attr("id", "line-gradient-"+Curve.Count)
                    .attr("gradientUnits", "userSpaceOnUse")
                    .attr("x1", 0)
                    .attr("y1", Curve.yScale(d3.min(Curve.data, d => d.value)))
                    .attr("x2", 0)
                    .attr("y2", Curve.yScale(d3.max(Curve.data, d => d.value)))
                    .selectAll("stop")
                    .data([
                        {offset: "0%", color: Curve.Color.low},
                        {offset: "100%", color: Curve.Color.high}
                    ])
                    .enter().append("stop")
                    .attr("offset", function(d) { return d.offset; })
                    .attr("stop-color", function(d) { return d.color; });

                var line = svg.append("path")
                    .datum(Curve.data)
                    .attr("z-index", -1)
                    .attr("fill", "none")
                    .attr("stroke", "url(#line-gradient-"+Curve.Count+")" )
                    .attr("stroke-width", 1)
                    .attr("d", Curve.line)
                    .transition()
                    .duration(1000)

                // Construction du cursseur
                Curve.focus = svg.append("g") 
                            .style("display", "none");

                // append the x line
                Curve.focus.append("line")
                    .attr("class", "x")
                    .style("stroke", Curve.Color.high)
                    .style("stroke-dasharray", "3,3") // pointillees
                    .style("opacity", 0.5)
                    .attr("y1", 0)
                    .attr("y2", height);

                // append the y line
                Curve.focus.append("line")
                    .attr("class", "y-"+Curve.Count)
                    .style("stroke", Curve.Color.high)
                    .style("stroke-dasharray", "3,3") // pointillees
                    .style("opacity", 0.5)
                    .attr("x1", width)
                    .attr("x2", width);

                // append the circle at the intersection 
                Curve.focus.append("circle")
                    .attr("class", "y-"+Curve.Count)
                    .style("fill", "none")
                    .style("stroke-width", "5px")
                    .style("stroke", "white")
                    .attr("r", 6);
                Curve.focus.append("circle")
                    .attr("class", "y-"+Curve.Count)
                    .style("fill", "none")
                    .style("stroke", Curve.Color.high)
                    .attr("r", 6);

                // place the value at the intersection
                Curve.focus.append("text")
                    .attr("class", "y1 shadow")
                    .attr("dx", 8)
                    .attr("dy", "-.3em");

                // place the date at the intersection
                Curve.focus.append("text")
                    .attr("class", "y3 shadow")
                    .attr("dx", 8)
                    .attr("dy", "1em");

            }
        )
    }

    var serieCounter=0;
    Request.serie.forEach(serie => GetData(serie))
    // append the rectangle to capture mouse
    var Sensitive = svg.append("rect")
        .attr("width", width)
        .attr("height", height)
        .style("fill", "none")
        .style("pointer-events", "all")
        .on("mouseover", function() { Request.serie.forEach(Curve => Curve.focus.style("display", null)); })
        .on("mouseout", function() { Request.serie.forEach(Curve => Curve.focus.style("display", "none")); })
        .on("mousemove", mousemove);
    

</script>
</html>